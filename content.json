{"meta":{"title":"卡莱折跃研究所","subtitle":null,"description":null,"author":"黑手型执心人士","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"感谢你来玩我的游戏，感谢你来看我的电影，感谢游戏来到我的世界","slug":"感谢你来玩我的游戏，感谢你来看我的电影，感谢游戏来到我的世界","date":"2018-04-02T14:51:06.000Z","updated":"2018-04-02T15:32:41.731Z","comments":true,"path":"2018/04/02/感谢你来玩我的游戏，感谢你来看我的电影，感谢游戏来到我的世界/","link":"","permalink":"http://yoursite.com/2018/04/02/感谢你来玩我的游戏，感谢你来看我的电影，感谢游戏来到我的世界/","excerpt":"","text":"观影体验：电影开头，机枪兵出场(应该是雷诺探长本人无疑了，据说有人看到了凯瑞甘)，有生之年看到星际兵种出现在荧幕，让我惊喜得捂住了嘴。 随后，斯巴达小队、岛铁雄到死都想要却从没得到的红摩托、闪光猎空、前不久刚上荧幕现在又客串的劳拉、即将上映的哥斯拉2、战锤40K里的机甲、隆、春丽、死射、侏罗纪恐龙、金刚、地狱咆哮、钢铁巨人、猛鬼街、鬼娃回魂、神族XX兵(还有一堆不认识或者没认出来的)，这一波波的彩蛋让我的鸡皮疙瘩起了好几回。 最让我感到惊喜的是，电影中间加入恐怖电影的桥段，IMAX的观感就像用VR在玩恐怖游戏。 电影中最燃的要数大东的那句:”高达模式转换”(大概意思)，全场欢呼声响起，旁边的妹纸发出了尖叫，右边基佬更是激动到双手高举，我更是想站起来，想到这是在电影院，才打消了这个想法。 元祖高达大战机械哥斯拉，这样的桥段，足够让每一个游戏宅感动的老泪横流。 最后的挑战，万恶之源雅达利更是将观众带回那个家用机时代。 PO几张图，对我来说，这几帧就值回票价了(图侵删)。 个人影评：“《Ready Player One》”是游戏宅狂欢，对游戏文化致敬得最好的电影，没有之一，可以说得是我这三年看过最好的科幻电影。电影中到处都有着彩蛋，有时候你甚至需要停下来一帧帧去找也未必能认全(据说本来有奥特曼和咸蛋超人的戏份，好像版权问题没出场，这也是个遗憾)。观影体验流畅，无明显拖沓的戏份，对于男女主的感情线也没有太过多的描述(观众可不是来看宅男虐狗的)，特效足以用炸裂来形容，特别是飙车桥段、闪灵电影和后面的大战部分，足以让普通的观众的肾上腺素狂飙。电影的结局，告诫着每一位Game Player:”just play for fun”，游戏的结局，并非获得胜利。虽然说一些比较奇怪的桥段，例如反派BOSS为什么不看工号，而是把员工的头盔一个个脱下来认人，男主的姨妈死后没有悲伤，反而在撩妹？游戏里为什么没有出现外挂(没看过原版小说，或许第二部是已经变成绿傲天的主角大战神仙玩家？或许可以请…逃)，但是丝毫不影响观影体验。总而言之，如果你是一个游戏玩家的话，这是一部早看早享受，晚看有折扣，不看后悔的电影；对于普通观众来说，除去那些不懂的彩蛋，那些动作科幻元素也足够挣回票价了。 “感谢你来玩我的游戏，感谢你来看我的电影，感谢游戏来到我的世界”","categories":[],"tags":[{"name":"影评","slug":"影评","permalink":"http://yoursite.com/tags/影评/"}]},{"title":"一天入门redis-RDB、AOF","slug":"2017-11-24-一天入门redis-RDB、AOF","date":"2017-11-24T03:50:22.000Z","updated":"2018-04-03T14:35:36.584Z","comments":true,"path":"2017/11/24/2017-11-24-一天入门redis-RDB、AOF/","link":"","permalink":"http://yoursite.com/2017/11/24/2017-11-24-一天入门redis-RDB、AOF/","excerpt":"RDB是什么？每隔一段时间将内存中的数据集快照写入硬盘中(二进制形式)。如果需要恢复，则在将其读到内存中。大概是怎么做的？redis会fork一个进程来持久化，先创建临时文件，等写入工作完成后，替换掉上次的快照文件(dump.rdb文件，位于src目录下)。该过程中redis不执行任何IO操作，以确保较好的性能。什么是Fork？拷贝当前的进程，保持变量、环境变量、程序计算器不变，但是作为远进程的子进","text":"RDB是什么？每隔一段时间将内存中的数据集快照写入硬盘中(二进制形式)。如果需要恢复，则在将其读到内存中。大概是怎么做的？redis会fork一个进程来持久化，先创建临时文件，等写入工作完成后，替换掉上次的快照文件(dump.rdb文件，位于src目录下)。该过程中redis不执行任何IO操作，以确保较好的性能。什么是Fork？拷贝当前的进程，保持变量、环境变量、程序计算器不变，但是作为远进程的子进 RDB是什么？每隔一段时间将内存中的数据集快照写入硬盘中(二进制形式)。如果需要恢复，则在将其读到内存中。 大概是怎么做的？redis会fork一个进程来持久化，先创建临时文件，等写入工作完成后，替换掉上次的快照文件(dump.rdb文件，位于src目录下)。该过程中redis不执行任何IO操作，以确保较好的性能。 什么是Fork？拷贝当前的进程，保持变量、环境变量、程序计算器不变，但是作为远进程的子进程。 存在问题最后一次持久化后的数据可能会丢失。恢复过程中redis停止工作，恢复时间比较长 使用场景对于数据恢复的完整不是很敏感的条件下 如何配置快照文件？(自定义或者默认目录下)sava 多长时间执行一次 如果超过多少次改变才执行根据项目具体需求进行配置。如果需要备份当前版本的数据，可以冷拷贝，也就是执行指令（最好通过定时任务实现） 1cp dump.rdb dump_new.rdb 如何手动触发备份？指令：save和bgsave区别：save会阻塞全部，而不管其他部分，bgsave的话会在后台操作，同时响应客户端请求。 如何恢复数据替换dump.rdb后重启就行 AOF是什么？AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件（appendonly.aof），以此达到记录数据库状态的目的.重启之后会读取该文件(重启时将所有记录的写操作指令执行一遍) 如何做 重写机制：当追加后的文件越来越大时，超过所设定AOF文件的最大容量，就会启动内容压缩，只保留可以恢复数据的最小指令集，对应命令 bgrewriteaof; 触发机制：相似的，redis会fork出一条新进程来重写文件，先写到临时文件再替换掉原文件，将库中的数据全部记录为set语句。（Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发，但并发量大一点的项目都会配置在4 5G以上）使用场景与RDB配合使用，开启后如果出现问题只会丢失一秒左右的数据。为什么不只使用AOF？redis默认重启时会会载入aof文件，并且往往AOF的数据比RDB更新（RDB中备份的数据不实时），但是RDB更适合用于备份数据库，并且AOF有丢失数据的可能性，两个一起开启更安全。如何配置如果当前src下有rdb的备份文件的话，需要先运行 rm -f dump.rdb 指令删除，再开启服务器。连接客户端，执行指令： 12345678[root@localhost src]# ./redis-cli -p 6379127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set a1 v1OK127.0.0.1:6379&gt; set a2 v2OK127.0.0.1:6379&gt; exit 发现文件下已经多出了appendonly.aof，使用cat指令进行查看。 12345678910111213141516171819*2$6SELECT$10*3$3set$2a1$2v1*3$3set$2a2$2v2 再使用vim编辑，随机加入一些字符。重启服务器，发现连接失败！ 123[root@localhost src]# ./redis-cli -p 6379Could not connect to Redis at 127.0.0.1:6379: Connection refusedCould not connect to Redis at 127.0.0.1:6379: Connection refused 使用修复指令 1234567./redis-check-aof --fix appendonly.aof [root@localhost src]# ./redis-check-aof --fix appendonly.aof 0x 17: Expected prefix &apos;*&apos;, got: &apos;d&apos;AOF analyzed: size=105, ok_up_to=23, diff=82This will shrink the AOF from 105 bytes, with 82 bytes, to 23 bytesContinue? [y/N]: ySuccessfully truncated AOF 再次连接，发现已经正常，查看appendonly.aof ，发现有语法错误的地方直接被删除了！ 什么情况下两种缓存都不需要使用？只做缓存，也就是不需要任何持久化的时候 优缺点对比RDB 优点 适合大规模数据，重启比aof快 最大化性能，唯一的会影响的性能的只有持久化过程中创建子线程去执行其他工作，父线程不会有操作磁盘等操作。 适合容灾恢复，压缩成单一文件适合传输 对数据完整性一致性要求性不高 每隔一段时间就会自动备份AOF优点多种同步方式： appendfsync always：每次写操作就立刻进行追加，性能比较差但是数据完整性比较好 appendfsync everysec：每一秒进行同步，宕机时可能会丢失数据，但是性能好，对于数据完整性要求不严格可以采用 从不同步 宕机时不用担心数据丢失问题，如果写一半可以使用自带的修复工具 自动重写，重写后的文件是最小化的 log可理解化，你甚至可以直接改写aof的log而不用连接服务器，而且可以通过备份该文件来做一些不可逆的操作。 RDB 缺点： 可能会丢失自上一次快照后的所有修改 fork时内存数据拷贝过程中2倍的膨胀性 数据集很大情况下，fork过程消耗很多时间，导致可能redis停止服务 AOF缺点： 相同的数据集AOF占用空间大于rdb，恢复速度也比rdb慢 使用appendfsync always性能比rdb慢 大量大读写情况下RDB也有更强大的可靠性 使用建议RDB只做紧急备份的话：只在从机上开启，而且间隔时间较长，15到20分钟才备份一次在开启AOF情况下，会带来持续的IO以及覆盖文件的阻塞，这时可以增大最大值。在主从模式下，主机可以不开启aof，但是如果主从机同时宕机的话，不能只执行简单的修复，而是应该对比主从的log文件进行修复，再重启，消耗时间比较长。 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"使用反射获取class并生成相应代码","slug":"2017-11-23-使用反射获取class并生成相应代码","date":"2017-11-23T02:32:22.000Z","updated":"2018-04-03T14:35:35.941Z","comments":true,"path":"2017/11/23/2017-11-23-使用反射获取class并生成相应代码/","link":"","permalink":"http://yoursite.com/2017/11/23/2017-11-23-使用反射获取class并生成相应代码/","excerpt":"package practice1;public class Person{ private String name; private String sex; private Integer age; private String idNo; private Boolean isMerried; public String getName() {","text":"package practice1;public class Person{ private String name; private String sex; private Integer age; private String idNo; private Boolean isMerried; public String getName() { 12345678910111213141516171819202122232425262728293031323334353637383940414243package practice1;public class Person&#123; private String name; private String sex; private Integer age; private String idNo; private Boolean isMerried; public String getName() &#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getIdNo() &#123; return idNo; &#125; public void setIdNo(String idNo) &#123; this.idNo = idNo; &#125; public Boolean getIsMerried() &#123; return isMerried; &#125; public void setIsMerried(Boolean isMerried) &#123; this.isMerried = isMerried; &#125; public Person(String idNo) &#123; &#125; public Person() &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package practice1;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Parameter;import java.lang.reflect.Type;/** * * @author 63574 * 已知问题 * 1、无法还原注解、注释,方法体内内容 * 2、访问级别不完善 * 3、没有还原带泛型的部分 * 4、没有还原包 */public class GenerateJava &#123; public static String PersonNmae=&quot;practice1.Person&quot;; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; System.out.println(ClassToJava(PersonNmae)); &#125; public static String ClassToJava(String ClassNmae) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class clazz=Class.forName(ClassNmae) ; StringBuilder javaContext=new StringBuilder(); javaContext.append(&quot;public class &quot;+clazz.getSimpleName()+&quot; &#123;\\n&quot;); Field[] fields = clazz.getDeclaredFields(); for(Field field:fields) &#123; field.setAccessible(true); javaContext.append(GetModifiers( field.getModifiers())+&quot; &quot;+field.getType().getSimpleName()+&quot; &quot;+field.getName()+&quot;;\\n&quot;); &#125; Method[] methods = clazz.getDeclaredMethods(); for(Method method:methods) &#123; method.setAccessible(true); javaContext.append(GetModifiers( method.getModifiers())+&quot; &quot;+method.getReturnType().getSimpleName()+&quot; &quot;+method.getName()+&quot;(&quot;); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); Parameter[] parameters = method.getParameters(); for(int i=0;i&lt;parameterTypes.length;i++) &#123; String simpleName = parameterTypes[i].getSimpleName(); //要获取正确参数名需要打开javac -parameters javaContext.append(simpleName+&quot; &quot;+parameters[i].getName()); &#125; javaContext.append(&quot;) &quot;); Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes(); if(exceptionTypes.length&gt;=1) &#123; javaContext.append(&quot;throws &quot;); &#125; for(int i=0;i&lt;exceptionTypes.length;i++) &#123; if(i!=0&amp;&amp;i!=exceptionTypes.length-1) &#123; javaContext.append(&quot;,&quot;); &#125; javaContext.append(exceptionTypes[i].getSimpleName()); &#125; javaContext.append(&quot; &#123;&#125;\\n&quot;); &#125; Constructor[] constructors = clazz.getConstructors(); for(Constructor constructor:constructors) &#123; constructor.setAccessible(true); javaContext.append(GetModifiers( constructor.getModifiers())+&quot; &quot;+constructor.getDeclaringClass().getSimpleName()+&quot;(&quot;); Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes(); Parameter[] parameters = constructor.getParameters(); for(int i=0;i&lt;parameterTypes.length;i++) &#123; String simpleName = parameterTypes[i].getSimpleName(); //要获取正确参数名需要打开javac -parameters javaContext.append(simpleName+&quot; &quot;+parameters[i].getName()); &#125; javaContext.append(&quot;) &quot;); Class&lt;?&gt;[] exceptionTypes = constructor.getExceptionTypes(); if(exceptionTypes.length&gt;=1) &#123; javaContext.append(&quot;throws &quot;); &#125; for(int i=0;i&lt;exceptionTypes.length;i++) &#123; if(i!=0&amp;&amp;i!=exceptionTypes.length-1) &#123; javaContext.append(&quot;,&quot;); &#125; javaContext.append(exceptionTypes[i].getSimpleName()); &#125; javaContext.append(&quot; &#123;&#125;\\n&quot;); &#125; javaContext.append(&quot;&#125;&quot;); return javaContext.toString(); &#125; private static String GetModifiers(int modifiers) &#123; if(modifiers==Modifier.PROTECTED) &#123; return &quot;&quot;; &#125; else if(modifiers==Modifier.PUBLIC) &#123; return &quot;public&quot;; &#125;else if(modifiers==Modifier.PRIVATE) &#123; return &quot;private&quot;; &#125; return &quot;&quot;; &#125;&#125; 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"class","slug":"class","permalink":"http://yoursite.com/tags/class/"}]},{"title":"序列化对象后单例模式被破坏解决方案","slug":"2017-11-23-序列化对象后单例模式被破坏解决方案","date":"2017-11-23T02:31:27.000Z","updated":"2018-04-03T14:35:36.220Z","comments":true,"path":"2017/11/23/2017-11-23-序列化对象后单例模式被破坏解决方案/","link":"","permalink":"http://yoursite.com/2017/11/23/2017-11-23-序列化对象后单例模式被破坏解决方案/","excerpt":"package org.ddd.section7.example7_6;import java.io.Serializable;public class Earth implements Serializable{ private static final long serialVersionUID = 1L; private volatile static Earth instan","text":"package org.ddd.section7.example7_6;import java.io.Serializable;public class Earth implements Serializable{ private static final long serialVersionUID = 1L; private volatile static Earth instan 123456789101112131415161718192021package org.ddd.section7.example7_6;import java.io.Serializable;public class Earth implements Serializable&#123; private static final long serialVersionUID = 1L; private volatile static Earth instance; public static Earth getInstance() &#123; if (instance == null) &#123; synchronized (Earth.class) &#123; if (instance == null) &#123; instance = new Earth(); &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.ddd.section7.example7_6;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class SerializeTool &#123; /** * 将对象序列化，并存在在本地文件中 * @param obj 被序列化的对象 * @param fileName 存储的本地文件名 */ public static void serialize(Object obj, String fileName) throws Exception&#123; File file = new File(fileName); //新建一个本地文件，用于存储，序列化的对象字节流 FileOutputStream output = new FileOutputStream(file); //文件输出流 ObjectOutputStream oos = new ObjectOutputStream(output); //对象输出流 oos.writeObject(obj); //将对象写入对象输出流中 oos.flush(); //提交对象输入流 oos.close(); output.close(); &#125; /** * 从本地文件中，通过反序列化获取对象 * @param fileName 本地存储序列化对象的文件 * @return 反序列化后的对象 */ public static Object deSerialize(String fileName) throws Exception&#123; File file = new File(fileName); //获取存储对象字节流的本地文件 FileInputStream input = new FileInputStream(file); //定义文件输入流 ObjectInputStream ois = new ObjectInputStream(input); //定义对象输入流 Object obj = ois.readObject(); //从对象输入流中读取对象 ois.close(); input.close(); return obj; &#125; /** * 打印指定文件的文件信息，包括文件名，文件大小等 * @param fileName 本地文件名 */ public static void printFileInfo(String fileName)&#123; File file = new File(fileName); //获取本地文件 System.out.println(&quot;-----------------------------&quot;); System.out.println(&quot;&lt;FileName&gt;: &quot; + fileName); //打印文件名 System.out.println(&quot;&lt;FileSize&gt;: &quot; + file.length() + &quot; bytes&quot;); //打印文件大小 System.out.println(&quot;-----------------------------&quot;); &#125;&#125; 12345678910111213package org.ddd.section7.example7_6;public class SerializeTest &#123; public static void main(String[] args) throws Exception&#123; Earth p = new Earth(); SerializeTool.serialize(p, &quot;temp&quot;); Earth pp = (Earth) SerializeTool.deSerialize(&quot;temp&quot;); System.out.println(p==pp); System.out.println(p); System.out.println(pp); &#125;&#125; 输出结果123falseorg.ddd.section7.example7_6.Earth@33909752org.ddd.section7.example7_6.Earth@3d4eac69 简要原因序列化过程中运用了反射的newInstance创建了对象返回 解决方法123456789101112131415161718192021222324252627282930package org.ddd.section7.example7_6;import java.io.Serializable;public class Earth implements Serializable&#123; private static final long serialVersionUID = 1L; private volatile static Earth instance; private Earth() &#123; // TODO Auto-generated constructor stub &#125; public static Earth getInstance() &#123; if (instance == null) &#123; synchronized (Earth.class) &#123; if (instance == null) &#123; instance = new Earth(); &#125; &#125; &#125; return instance; &#125; private Object readResolve() &#123; System.out.println(&quot;被调用了&quot;); return getInstance(); &#125; private Object writeReplace() &#123; return getInstance(); &#125;&#125; 输出123falseorg.ddd.section7.example7_6.Earth@3d4eac69org.ddd.section7.example7_6.Earth@776ec8df 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"},{"name":"class","slug":"class","permalink":"http://yoursite.com/tags/class/"}]},{"title":"java.lang.NoClassDefFoundError net.sf.ezmorph.Morpher问题解决-pom版","slug":"2017-11-23-java.lang.NoClassDefFoundError net.sf.ezmorph.Morpher问题解决-pom版","date":"2017-11-23T02:30:55.000Z","updated":"2018-04-03T14:35:36.205Z","comments":true,"path":"2017/11/23/2017-11-23-java.lang.NoClassDefFoundError net.sf.ezmorph.Morpher问题解决-pom版/","link":"","permalink":"http://yoursite.com/2017/11/23/2017-11-23-java.lang.NoClassDefFoundError net.sf.ezmorph.Morpher问题解决-pom版/","excerpt":"net.sf.json-lib json-lib 2.4 jdk15","text":"net.sf.json-lib json-lib 2.4 jdk15 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-httpclient&lt;/groupId&gt; &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ezmorph&lt;/groupId&gt; &lt;artifactId&gt;ezmorph&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt; 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"jdk","slug":"jdk","permalink":"http://yoursite.com/tags/jdk/"}]},{"title":"JAVA-任意对象转换成JSON，json转换成指定对象","slug":"2017-11-23-JAVA-任意对象转换成JSON，json转换成指定对象","date":"2017-11-23T02:29:27.000Z","updated":"2018-04-03T14:35:30.725Z","comments":true,"path":"2017/11/23/2017-11-23-JAVA-任意对象转换成JSON，json转换成指定对象/","link":"","permalink":"http://yoursite.com/2017/11/23/2017-11-23-JAVA-任意对象转换成JSON，json转换成指定对象/","excerpt":"任意对象转换成JSON只支持字符和基本类型代码package ztf.question3;public class Address { private String province; private String street; public Address() { } public Address(String pro,String street){","text":"任意对象转换成JSON只支持字符和基本类型代码package ztf.question3;public class Address { private String province; private String street; public Address() { } public Address(String pro,String street){ 任意对象转换成JSON只支持字符和基本类型 代码123456789101112131415161718192021222324252627282930package ztf.question3;public class Address &#123; private String province; private String street; public Address() &#123; &#125; public Address(String pro,String street)&#123; this.province=pro; this.street=street; &#125; public String getProvince()&#123; return this.province; &#125; public void setProvince(String province)&#123; this.province=province; &#125; public String getStreet()&#123; return this.street; &#125; public void setStreet(String street)&#123; this.street=street; &#125; @Override public String toString() &#123; return &quot;Address [province=&quot; + province + &quot;, street=&quot; + street + &quot;]&quot;; &#125; &#125; 1234567891011121314151617181920212223package ztf.question3;import java.io.File;import java.io.FileNotFoundException;import java.io.FileWriter;import net.sf.json.JSON;import net.sf.json.JSONSerializer;public class Application &#123; public static void main(String[] args)&#123; Person person=new Person(); person.setName(&quot;ddd&quot;); person.setAge(23); Address address=new Address(&quot;chonqqing&quot;,&quot;Hong Guang Street&quot;); person.setAddress(address); System.out.println(ObjectToJson.writeJson(person.getClass(), person)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package ztf.question3;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ObjectToJson &#123; public static String writeJson(Class clazz,Object obj)&#123; StringBuilder stringBuilder=new StringBuilder(); try&#123; stringBuilder.append(&quot;&#123;&quot;); Field[] declaredFields = clazz.getDeclaredFields(); for(Field field:declaredFields) &#123; field.setAccessible(true); stringBuilder.append(&quot;\\&quot;&quot;+field.getName()+&quot;\\&quot;:&quot;); Class&lt;?&gt; type = field.getType(); if(type.isPrimitive()||type==String.class) &#123; Method m = (Method) clazz.getMethod( &quot;get&quot; + getMethodName(field.getName())); stringBuilder.append(&quot;\\&quot;&quot;+m.invoke(obj)+&quot;\\&quot;&quot;); &#125;else &#123; Method m = (Method) clazz.getMethod( &quot;get&quot; + type.getSimpleName()); stringBuilder.append(writeJson(field.getType(),m.invoke(obj))); &#125; stringBuilder.append(&quot;,&quot;); &#125; return reChange(stringBuilder.toString()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; private static String reChange(String string) &#123; // TODO Auto-generated method stub return string.substring(0,string.length()-1)+&quot;&#125;&quot;; &#125; private static String getMethodName(String name) &#123; // TODO Auto-generated method stub return name.substring(0, 1).toUpperCase() + name.substring(1); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package ztf.question3;public class Person &#123; private String name; private int age; private Address address; public Person()&#123; this.name=&quot;&quot;; &#125; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name=name; &#125; public int getAge()&#123; return this.age; &#125; public void setAge(int age)&#123; this.age=age; &#125; public Address getAddress()&#123; return this.address; &#125; public void setAddress(Address address)&#123; this.address=address; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &quot;]&quot;; &#125; &#125; json转换成指定对象需要修改代码才能支持其他类型 代码1234567891011121314package ztf.question4;import ztf.question3.Person;public class Application &#123; public static void main(String[] args)&#123; String json=new String(&quot;&#123;\\&quot;name\\&quot;:\\&quot;ddd\\&quot;,\\&quot;age\\&quot;:\\&quot;23\\&quot;,\\&quot;address\\&quot;:&#123;\\&quot;province\\&quot;:\\&quot;chonqqing\\&quot;,\\&quot;street\\&quot;:\\&quot;Hong Guang Street\\&quot;&#125;&#125;\\r\\n&quot; + &quot;&quot;); System.out.println((Person)JsonToPerson.readJson(json,Person.class)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package ztf.question4;import java.lang.reflect.Field;import java.lang.reflect.Method;import net.sf.json.JSONObject;import ztf.question3.Address;public class JsonToPerson &#123; public static Object readJson(String json,Class class1) &#123; JSONObject jsoj = JSONObject.fromObject(json); try &#123; Object obj=class1.newInstance(); Field[] fields = class1.getDeclaredFields(); for(Field field:fields) &#123; Class&lt;?&gt; type = field.getType(); Method method = class1.getMethod(&quot;set&quot;+getMethodName(field.getName()),type); if(type.isPrimitive()||&quot;java.lang.String&quot;.equals(type.getName())) &#123; //这里应该有更好的解决方法，需要查看其他框架的源码 if(&quot;java.lang.String&quot;.equals(type.getName())) &#123; method.invoke(obj, jsoj.get(field.getName())); &#125;else if(&quot;int&quot;.equals(type.getName()))&#123; method.invoke(obj, Integer.valueOf(jsoj.get(field.getName()).toString())); &#125; &#125;else &#123; method.invoke(obj, (Address)readJson(jsoj.get(field.getName()).toString(),type)); &#125; &#125; return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static String fixEleName(String name) &#123; int lastIndexOf = name.lastIndexOf(&apos;.&apos;); if(lastIndexOf&lt;=-1) return name; return name.substring(lastIndexOf+1, lastIndexOf+2).toLowerCase()+name.substring(lastIndexOf+2); &#125; private static String getMethodName(String name) &#123; // TODO Auto-generated method stub return name.substring(0, 1).toUpperCase() + name.substring(1); &#125;&#125; 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"},{"name":"class","slug":"class","permalink":"http://yoursite.com/tags/class/"}]},{"title":"基于JAVAFX仿网易云音乐播放器","slug":"2017-08-15-基于JAVAFX仿网易云音乐播放器","date":"2017-08-15T03:55:58.000Z","updated":"2018-04-03T14:35:35.884Z","comments":true,"path":"2017/08/15/2017-08-15-基于JAVAFX仿网易云音乐播放器/","link":"","permalink":"http://yoursite.com/2017/08/15/2017-08-15-基于JAVAFX仿网易云音乐播放器/","excerpt":"与网易云相仿的界面，以酷炫黑为主题，加入歌词的滚动，以及加入了网易云没有的动画效果。能够播放MP3，flac两种网易云播放器使用的格式，界面逻辑控制基本与网易云一致，包括上一首、下一首、播放暂停、播放全部、四种不同的播放循环模式、设为我的喜爱等功能，支持更多格式，包括wav,ape,wavpack,au,aiff等格式的支持，以及对歌词滚动的控制。完成对Flac、MP3两种格式的元数据解析(包括图片","text":"与网易云相仿的界面，以酷炫黑为主题，加入歌词的滚动，以及加入了网易云没有的动画效果。能够播放MP3，flac两种网易云播放器使用的格式，界面逻辑控制基本与网易云一致，包括上一首、下一首、播放暂停、播放全部、四种不同的播放循环模式、设为我的喜爱等功能，支持更多格式，包括wav,ape,wavpack,au,aiff等格式的支持，以及对歌词滚动的控制。完成对Flac、MP3两种格式的元数据解析(包括图片 与网易云相仿的界面，以酷炫黑为主题，加入歌词的滚动，以及加入了网易云没有的动画效果。能够播放MP3，flac两种网易云播放器使用的格式，界面逻辑控制基本与网易云一致，包括上一首、下一首、播放暂停、播放全部、四种不同的播放循环模式、设为我的喜爱等功能，支持更多格式，包括wav,ape,wavpack,au,aiff等格式的支持，以及对歌词滚动的控制。完成对Flac、MP3两种格式的元数据解析(包括图片),以及使用XML进行保存，支持歌词的解析，支持更多格式的Tag基本元数据解析，拥有四种对歌曲不同的搜索 项目地址：https://github.com/EnTaroAdunZ/MusicPlayer.git 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://yoursite.com/tags/javafx/"}]},{"title":"PowerDesigner16.5 自定义默认值去除引号","slug":"2017-08-07-PowerDesigner16.5 自定义默认值去除引号","date":"2017-08-07T00:51:25.000Z","updated":"2018-04-03T14:35:36.297Z","comments":true,"path":"2017/08/07/2017-08-07-PowerDesigner16.5 自定义默认值去除引号/","link":"","permalink":"http://yoursite.com/2017/08/07/2017-08-07-PowerDesigner16.5 自定义默认值去除引号/","excerpt":"Database -&gt; Edit Currnet DBMS -&gt; Script -&gt; Sql -&gt; Sytax 不知道为什么找不到别的教程说的 Format -&gt; CaseSensitivityUsingQuote","text":"Database -&gt; Edit Currnet DBMS -&gt; Script -&gt; Sql -&gt; Sytax 不知道为什么找不到别的教程说的 Format -&gt; CaseSensitivityUsingQuote Database -&gt; Edit Currnet DBMS -&gt; Script -&gt; Sql -&gt; Sytax 不知道为什么找不到别的教程说的 Format -&gt; CaseSensitivityUsingQuote 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"powerdesigner","slug":"powerdesigner","permalink":"http://yoursite.com/tags/powerdesigner/"}]},{"title":"初识UML(1)","slug":"2017-08-01-初识UML(1)","date":"2017-07-31T18:42:21.000Z","updated":"2018-04-03T14:35:35.936Z","comments":true,"path":"2017/08/01/2017-08-01-初识UML(1)/","link":"","permalink":"http://yoursite.com/2017/08/01/2017-08-01-初识UML(1)/","excerpt":"UML概述:统一建模语言,是一套符号规定,用于帮助描述思想和方法,帮助我们分析和设计,帮助思考和记录思路的结果.描述建模的概念,类/对象/关联/行为/接口/用力/包/顺序/协作/状态/指责.简单来说解决编码前的设计问题 UML特点: 基于面向对象的可视化建模语言,采用本身定义的图形符号作为建模语言,通过建立图形之间的各种关系来描述模型关系. 通用型 可视性 分析设计专用","text":"UML概述:统一建模语言,是一套符号规定,用于帮助描述思想和方法,帮助我们分析和设计,帮助思考和记录思路的结果.描述建模的概念,类/对象/关联/行为/接口/用力/包/顺序/协作/状态/指责.简单来说解决编码前的设计问题 UML特点: 基于面向对象的可视化建模语言,采用本身定义的图形符号作为建模语言,通过建立图形之间的各种关系来描述模型关系. 通用型 可视性 分析设计专用 UML概述:统一建模语言,是一套符号规定,用于帮助描述思想和方法,帮助我们分析和设计,帮助思考和记录思路的结果.描述建模的概念,类/对象/关联/行为/接口/用力/包/顺序/协作/状态/指责.简单来说解决编码前的设计问题UML特点: 基于面向对象的可视化建模语言,采用本身定义的图形符号作为建模语言,通过建立图形之间的各种关系来描述模型关系. 通用型 可视性 分析设计专用语言 只是一种表达方法,而不是建模方法 描述语言,不能直接验证理论 图的分类 类图 对象图 用例图:使用场景 时序图:随着时间推移程序发生的变化 活动图:流程图 状态图 领域模型图 构件图:类之间系统结构 协作图 部署图:描述系统如何部署 用例图参与者：参与者不是特指人，而是指系统以外的，在使用系统或与系统交互中所扮演的角色．因此参与者可以是人，可以是事物，也可以是其他系统．场景系统边界用例：文本的场景描述，通过用户的使用场景来获取需求．最好使用最终用户或者领域专家的语言． 简要描述：对用例的角色，目的的简要描述 前置条件：执行用例之前系统必须处于的状态，或者要满足的条件 基本事件流：描述该用例的基本流程，指每个流程正常运行发生的事情，没有其他备选流和异常流， 其他时间流：表示这个行为或流程是可选的或备选的，并不是总要执行他们； 异常时间流：表示发生了某些非正常的事情所要执行的流程． 后置条件：用例执行结束后所处的状态． 类图倚赖:A类依赖B类,A类离开B类无法编译,一般不反映依赖关系关联关系:属性之间一对多,多对多关系聚合关系:整体和部分的关系,整体和部分可以分开,聚合关系是关联关系的特征.组合关系:一般都是双向,many一方用菱形表示是组合关系泛化关系:泛化关系实际上是继承关系,他是依赖关系的特征 #####活动图 在UML里,活动图本质上就是流程图,它描述系统中事物或对象的变化流程。 开始状态：一个活动图一定有一个且只有一个开始状态，开始状态用一个实心圆表示；结束状态：一个活动图必须有至少一个结束状态，可以有多个结束状态（正常结束状态和分支流程结束状态）；活动：代表一个动作；活动流：代表活动（流程）的运行方向；分支：代表流程中的判断或者选择；分叉和汇合：分叉代表流程中并行执行的流程；汇合代表并行执行的流程的汇总；泳道：泳道可以规划出参与活动的各个角色； 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[]},{"title":"8086汇编-图示HANOI的移动过程","slug":"2017-07-31-8086汇编-图示HANOI的移动过程","date":"2017-07-31T02:38:42.000Z","updated":"2018-04-03T14:35:36.454Z","comments":true,"path":"2017/07/31/2017-07-31-8086汇编-图示HANOI的移动过程/","link":"","permalink":"http://yoursite.com/2017/07/31/2017-07-31-8086汇编-图示HANOI的移动过程/","excerpt":"DATAS SEGMENT ZHUZI_A DW 0,100 dup(?);表示当前柱子上有哪几个盘 ZHUZI_B DW 0,100 dup(?);表示当前柱子上有哪几个盘 ZHUZI_C DW 0,100 dup(?);表示当前柱子上有哪几个盘 tip db ‘input n:’,0ah,0dh,’$’ ;提示 n db 0 ;多少重","text":"DATAS SEGMENT ZHUZI_A DW 0,100 dup(?);表示当前柱子上有哪几个盘 ZHUZI_B DW 0,100 dup(?);表示当前柱子上有哪几个盘 ZHUZI_C DW 0,100 dup(?);表示当前柱子上有哪几个盘 tip db ‘input n:’,0ah,0dh,’$’ ;提示 n db 0 ;多少重 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391DATAS SEGMENT ZHUZI_A DW 0,100 dup(?);表示当前柱子上有哪几个盘 ZHUZI_B DW 0,100 dup(?);表示当前柱子上有哪几个盘 ZHUZI_C DW 0,100 dup(?);表示当前柱子上有哪几个盘 tip db &apos;input n:&apos;,0ah,0dh,&apos;$&apos; ;提示 n db 0 ;多少重 tempn db 0;临时存放N值 len_left dw 0;哪里开始打印 len_right dw 0;哪里结束打印 charA dw 1;当前A对应哪个柱子 charB dw 2;当前B对应哪个柱子 charC dw 3;当前C对应哪个柱子 mover dw 0;偏移位置DATAS ENDSSTACKS SEGMENT dw 80 dup(?)STACKS ENDS;**************************************************************;如果需要调节速度，请到最下方的子程序sleep中调节;7,8层以上推荐将dx设置为1;递归中没有使用栈放参数，不会轻易出现栈溢出;请输入十进制的数，并输入回车结束;18层以上的效果将显示不完整或者不完美;**************************************************************CODES SEGMENT ASSUME CS:CODES,DS:DATAS,SS:STACKSmain proc far START: push ds sub ax,ax push ax mov bx,0 mov ax,DATAS mov ds,ax;DOS返回数据 lea dx,tip mov ah,09h;显示提示 int 21hinput: mov ah,1 int 21h;接受输入 cmp al,0DH jz exitInput sub al,30h mov bl,al xor bh,bh xor ax,ax mov al,n mov cl,10 mul cl add ax,bx mov n,al jmp inputexitInput: ;初始化 call init call Print call hanoi ret main endp;------------------------------------------------------------------hanoi proc near push ax XOR AH,AH MOV AL,n cmp ax,1 jnz dfs call move call Print jmp exitDfsdfs: call Store1 call hanoi call REC1 call Store3 call hanoi call REC3 call Store2 call hanoi call REC2exitDfs:pop axrethanoi ENDP;------------------------------------------------------------------move PROC FAR PUSH AX PUSH BX PUSH SI PUSH DI PUSH DX mov AX,charA mov BX,charC ;SI cmp AX,1 jnz exitJudCharA_1 lea si,ZHUZI_A jmp exitJudCharAexitJudCharA_1: cmp AX,2 jnz exitJudCharA_2 lea si,ZHUZI_B jmp exitJudCharAexitJudCharA_2: lea si,ZHUZI_CexitJudCharA: ;DI cmp BX,1 jnz exitJudCharC_1 lea di,ZHUZI_A jmp exitJudCharCexitJudCharC_1: cmp BX,2 jnz exitJudCharC_2 lea di,ZHUZI_B jmp exitJudCharCexitJudCharC_2: lea di,ZHUZI_CexitJudCharC: ;结束 MOV AX,[SI] MOV BX,[DI] ADD AX,AX ADD BX,BX ADD BX,2 MOV mover,AX add si,mover MOV DX,[SI] sub si,mover add DI,BX MOV [DI],DX sub DI,BX MOV DX,[DI] inc dx MOV [DI],DX MOV DX,[SI] dec dx MOV [SI],DX POP DX POP DI POP SI POP BX POP AX RET move ENDP ;------------------------------------------------------------------ Print PROC FAR push ax push bx push cx push dx push si mov ah,0;把屏幕分为320*200像素，四色 mov al,04h int 10h;取光笔 MOV DX,180 MOV CX,50 LEA SI,ZHUZI_A MOV BX,[SI]PrintA: cmp bx,0 jz exitA PUSH BX PUSH AX add si,2 MOV AX,[SI] xor bx,bx MOV BL,2 MUL BL MOV CX,50 SUB CX,AX SUB CX,5 MOV len_left,CX MOV CX,50 ADD CX,AX ADD CX,5 MOV len_right,CX POP AX POP BX MOV CX,len_leftPrintA_1: mov al,5 mov ah,0ch int 10h inc cx cmp cx,len_right jbe PrintA_1 sub dx,5 sub bx,1 jnz PrintAexitA: MOV DX,180 LEA SI,ZHUZI_B MOV BX,[SI]PrintB: cmp bx,0 jz exitB PUSH BX PUSH AX add si,2 MOV AX,[SI] xor bx,bx MOV BL,2 MUL BL MOV CX,150 SUB CX,AX SUB CX,5 MOV len_left,CX MOV CX,150 ADD CX,AX ADD CX,5 MOV len_right,CX POP AX POP BX MOV CX,len_leftPrintB_1: mov al,5 mov ah,0ch int 10h inc cx cmp cx,len_right jbe PrintB_1 sub dx,5 sub bx,1 jnz PrintBexitB: MOV DX,180 LEA SI,ZHUZI_C MOV BX,[SI]PrintC: cmp bx,0 jz exitC PUSH BX PUSH AX add si,2 MOV AX,[SI] xor bx,bx MOV BL,2 MUL BL MOV CX,250 SUB CX,AX SUB CX,5 MOV len_left,CX MOV CX,250 ADD CX,AX add CX,5 MOV len_right,CX POP AX POP BX MOV CX,len_leftPrintC_1: mov al,5 mov ah,0ch int 10h inc cx cmp cx,len_right jbe PrintC_1 sub dx,5 sub bx,1 jnz PrintC exitC:;打印柱子;------------------------------------------------------------------ MOV CX,50 MOV DX,50printZhuZi1: mov al,6 mov ah,0ch int 10h inc DX cmp DX,180 jbe printZhuZi1 add CX,100 MOV DX,50printZhuZi2: mov al,6 mov ah,0ch int 10h inc DX cmp DX,180 jbe printZhuZi2 add CX,100 MOV DX,50printZhuZi3: mov al,6 mov ah,0ch int 10h inc DX cmp DX,180 jbe printZhuZi3 call sleep;------------------------------------------------------------------ pop si pop dx pop cx pop bx pop ax RET Print ENDP ;------------------------------------------------------------------ Store1 proc near PUSH AX PUSH BX MOV AX,charB MOV BX,charC MOV charB,BX MOV charC,AX dec n POP BX POP AX retStore1 endpREC1 proc near PUSH AX PUSH BX MOV AX,charB MOV BX,charC MOV charB,BX MOV charC,AX INC N POP BX POP AX retREC1 endp;------------------------------------------------------------------ Store2 proc near PUSH AX PUSH BX MOV AX,charA MOV BX,charB MOV charA,BX MOV charB,AX dec n POP BX POP AX retStore2 endpREC2 proc near PUSH AX PUSH BX MOV AX,charA MOV BX,charB MOV charA,BX MOV charB,AX INC N POP BX POP AX retREC2 endp;------------------------------------------------------------------Store3 proc near PUSH AX xor ax,ax MOV Al,n MOV tempn,Al mov n,1 POP AX retStore3 ENDPREC3 proc near PUSH AX xor ax,ax MOV Al,tempn MOV n,Al POP AX retREC3 ENDP;------------------------------------------------------------------init proc near;下面开始初始化三个数 MOV AX,DATAS MOV DS,AX LEA SI,ZHUZI_A xor ah,ah mov al,n MOV [SI],ax xor cx,cx mov cl,ninitZhuZiA: add si,2 MOV [SI],cxloop initZhuZiA ret init endp;------------------------------------------------------------------sleep procretsleep endpCODES ENDSend 本文章由[谙忆]编写， 所有权利保留。欢迎转载，分享是进步的源泉。 转载请注明出处：http://chenhaoxiang.cn本文源自【人生之旅_谙忆的博客】","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]}]}